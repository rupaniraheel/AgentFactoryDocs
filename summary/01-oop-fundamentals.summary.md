### Core Concept

OOP solves the scaling problem: when you have many similar entities (accounts, characters, objects), define structure once via a class and create unlimited instances. Procedural code requires N copies of functions for N entities; OOP requires one class definition.

### Key Mental Models

**The Cookie Cutter Analogy**: A class is the cutter (template), objects are cookies. One blueprint, infinite instances. Procedural code with 100 accounts needs 100 variables + 100 duplicate functions. OOP bundles data and methods—each object manages its own state.

### Critical Patterns

Decision tree: Do you have 3+ similar entities? Will the system grow? Do bug fixes need multiple places? If yes—use OOP. Recognition: when copy-pasting functions, OOP is the answer.

### AI Collaboration Keys

Ask AI to show code explosion before writing it. Challenge its explanations with edge cases (state isolation, scaling). This transforms passive understanding into active reasoning.

### Common Mistakes

Treating OOP as always correct. Using OOP prematurely for simple scripts (calculating π doesn't need classes). Skipping problem discovery and jumping to definitions.

### Connections

Prerequisites: functions and variable scope. This lesson unlocks OOP fundamentals—all future lessons build on how objects manage independent state.
